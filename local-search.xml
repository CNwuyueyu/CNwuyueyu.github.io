<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2-工具与软件-5-TensorFlow</title>
    <link href="/2023/09/08/2-%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BD%AF%E4%BB%B6-5-TensorFlow/"/>
    <url>/2023/09/08/2-%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BD%AF%E4%BB%B6-5-TensorFlow/</url>
    
    <content type="html"><![CDATA[<h2 id="环境的安装"><a href="#环境的安装" class="headerlink" title="环境的安装"></a>环境的安装</h2><p>选择pycharm自动安装（会自动安装其他依赖，十分方便）</p><p><img src="/../images/2-%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BD%AF%E4%BB%B6-5-TensorFlow/image-20230911171426713.png" alt="TensorFlow的安装"></p><p>所需安装：</p><ul><li>conda</li><li>tensorflow</li></ul><h2 id="1-1-人工智能三学派"><a href="#1-1-人工智能三学派" class="headerlink" title="1.1 人工智能三学派"></a>1.1 人工智能三学派</h2><p><img src="/../images/2-%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BD%AF%E4%BB%B6-5-TensorFlow/image-20230911172021989.png" alt="三学派"></p><p>行为主义：机器人的摔倒预测</p><p>符号主义：用公式描述的人工智能，让PC具有了理性思维</p><p>连接主义：仿造人的感性思维</p><p><img src="/../images/2-%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BD%AF%E4%BB%B6-5-TensorFlow/image-20230911172351969.png" alt="神经网络是连接主义"></p><h2 id="1-2神经网络的设计过程"><a href="#1-2神经网络的设计过程" class="headerlink" title="1.2神经网络的设计过程"></a>1.2神经网络的设计过程</h2><p>用神经网络实现鸢尾花的分类：<strong>梯度下降</strong></p><p>目的：找到一组参数w和b，使得损失函数最小。</p><p>梯度：函数对各参数<strong>求偏导</strong>后的向量。 <u>梯度下降的方向是函数减小的方向</u></p><p>梯度下降法：沿损失函数梯度下降的方向，寻找损失函数的最小值，得到最优参数的方法</p><p><img src="/../images/2-%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BD%AF%E4%BB%B6-5-TensorFlow/image-20230912105643070.png" alt="梯度下降示意图"></p><p>学习率（lr）：设置过小，收敛缓慢；设置过大，无法收敛（找不到最小值）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2-工具与软件-4-PyTorch</title>
    <link href="/2023/09/08/2-%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BD%AF%E4%BB%B6-4-PyTorch/"/>
    <url>/2023/09/08/2-%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BD%AF%E4%BB%B6-4-PyTorch/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2-工具与软件-3-数据分析实战</title>
    <link href="/2023/09/08/2-%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BD%AF%E4%BB%B6-3-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"/>
    <url>/2023/09/08/2-%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BD%AF%E4%BB%B6-3-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2-工具与软件-2-Pandas</title>
    <link href="/2023/09/08/2-%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BD%AF%E4%BB%B6-2-Pandas/"/>
    <url>/2023/09/08/2-%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BD%AF%E4%BB%B6-2-Pandas/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2-工具与软件-1-Numpy</title>
    <link href="/2023/09/08/2-%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BD%AF%E4%BB%B6-1-Numpy/"/>
    <url>/2023/09/08/2-%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%BD%AF%E4%BB%B6-1-Numpy/</url>
    
    <content type="html"><![CDATA[<p>NumPy用于数据分析，提供了大量的维度数组与矩阵运算，NumPy 通常与 SciPy（Scientific Python）和 Matplotlib（绘图库）一起使用。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>sudo apt-get install python3-numpy python3-scipy python3-matplotlib ipython ipython-notebook python-pandas python-sympy python-nose</code></p><p>或使用pycharm在import numpy后自动导入。</p><h3 id="N-维数组对象-ndarray"><a href="#N-维数组对象-ndarray" class="headerlink" title="N 维数组对象 ndarray"></a>N 维数组对象 ndarray</h3><p>ndarray 中的每个元素在内存中都有相同存储大小的区域</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.array(<span class="hljs-built_in">object</span>, dtype = <span class="hljs-literal">None</span>, copy = <span class="hljs-literal">True</span>, order = <span class="hljs-literal">None</span>, subok = <span class="hljs-literal">False</span>, ndmin = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">object</td><td align="left">数组或嵌套的数列</td></tr><tr><td align="left">dtype</td><td align="left">数组元素的数据类型，可选</td></tr><tr><td align="left">copy</td><td align="left">对象是否需要复制，可选</td></tr><tr><td align="left">order</td><td align="left">创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）</td></tr><tr><td align="left">subok</td><td align="left">默认返回一个与基类类型一致的数组</td></tr><tr><td align="left">ndmin</td><td align="left">指定生成数组的最小维度</td></tr></tbody></table><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>int8, int16, int32, int64 四种数据类型可以使用字符串 ‘i1’, ‘i2’,’i4’,’i8’ 代替</p><table><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">bool_</td><td align="left">布尔型数据类型（True 或者 False）</td></tr><tr><td align="left">int_</td><td align="left">默认的整数类型（类似于 C 语言中的 long，int32 或 int64）</td></tr><tr><td align="left">intc</td><td align="left">与 C 的 int 类型一样，一般是 int32 或 int 64</td></tr><tr><td align="left">intp</td><td align="left">用于索引的整数类型（类似于 C 的 ssize_t，一般情况下仍然是 int32 或 int64）</td></tr><tr><td align="left">int8</td><td align="left">字节（-128 to 127）</td></tr><tr><td align="left">int16</td><td align="left">整数（-32768 to 32767）</td></tr><tr><td align="left">int32</td><td align="left">整数（-2147483648 to 2147483647）</td></tr><tr><td align="left">int64</td><td align="left">整数（-9223372036854775808 to 9223372036854775807）</td></tr><tr><td align="left">uint8</td><td align="left">无符号整数（0 to 255）</td></tr><tr><td align="left">uint16</td><td align="left">无符号整数（0 to 65535）</td></tr><tr><td align="left">uint32</td><td align="left">无符号整数（0 to 4294967295）</td></tr><tr><td align="left">uint64</td><td align="left">无符号整数（0 to 18446744073709551615）</td></tr><tr><td align="left">float_</td><td align="left">float64 类型的简写</td></tr><tr><td align="left">float16</td><td align="left">半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td></tr><tr><td align="left">float32</td><td align="left">单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td></tr><tr><td align="left">float64</td><td align="left">双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td></tr><tr><td align="left">complex_</td><td align="left">complex128 类型的简写，即 128 位复数</td></tr><tr><td align="left">complex64</td><td align="left">复数，表示双 32 位浮点数（实数部分和虚数部分）</td></tr><tr><td align="left">complex128</td><td align="left">复数，表示双 64 位浮点数（实数部分和虚数部分）</td></tr></tbody></table><p>在创建dtype中（数据类型对象），每个内建类型都有一个唯一定义它的字符代码</p><table><thead><tr><th align="left">字符</th><th align="left">对应类型</th></tr></thead><tbody><tr><td align="left">b</td><td align="left">布尔型</td></tr><tr><td align="left">i</td><td align="left">(有符号) 整型</td></tr><tr><td align="left">u</td><td align="left">无符号整型 integer</td></tr><tr><td align="left">f</td><td align="left">浮点型</td></tr><tr><td align="left">c</td><td align="left">复数浮点型</td></tr><tr><td align="left">m</td><td align="left">timedelta（时间间隔）</td></tr><tr><td align="left">M</td><td align="left">datetime（日期时间）</td></tr><tr><td align="left">O</td><td align="left">(Python) 对象</td></tr><tr><td align="left">S, a</td><td align="left">(byte-)字符串</td></tr><tr><td align="left">U</td><td align="left">Unicode</td></tr><tr><td align="left">V</td><td align="left">原始数据 (void)</td></tr></tbody></table><h3 id="Numpy数组"><a href="#Numpy数组" class="headerlink" title="Numpy数组"></a>Numpy数组</h3><p>维数——秩（rank），维度——轴（axis）</p><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ndarray.ndim</td><td align="left">秩，即轴的数量或维度的数量</td></tr><tr><td align="left">ndarray.shape</td><td align="left">数组的维度，对于矩阵，n 行 m 列</td></tr><tr><td align="left">ndarray.size</td><td align="left">数组元素的总个数，相当于 .shape 中 n*m 的值</td></tr><tr><td align="left">ndarray.dtype</td><td align="left">ndarray 对象的元素类型</td></tr><tr><td align="left">ndarray.itemsize</td><td align="left">ndarray 对象中每个元素的大小，以字节为单位</td></tr><tr><td align="left">ndarray.flags</td><td align="left">ndarray 对象的内存信息</td></tr><tr><td align="left">ndarray.real</td><td align="left">ndarray元素的实部</td></tr><tr><td align="left">ndarray.imag</td><td align="left">ndarray 元素的虚部</td></tr><tr><td align="left">ndarray.data</td><td align="left">包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</td></tr></tbody></table><p>数组的创建</p><p><code>numpy.empty</code> 方法用来创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.empty(shape, dtype = <span class="hljs-built_in">float</span>, order = <span class="hljs-string">&#x27;C&#x27;</span>)<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">shape</td><td align="left">数组形状</td></tr><tr><td align="left">dtype</td><td align="left">数据类型，可选</td></tr><tr><td align="left">order</td><td align="left">有”C”和”F”两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。</td></tr></tbody></table><p><code>numpy.zeros</code> 创建指定大小的数组，数组元素以 0 来填充：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.zeros(shape, dtype = <span class="hljs-built_in">float</span>, order = <span class="hljs-string">&#x27;C&#x27;</span>)<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">shape</td><td align="left">数组形状</td></tr><tr><td align="left">dtype</td><td align="left">数据类型，可选 默认为浮点数</td></tr><tr><td align="left">order</td><td align="left">‘C’ 用于 C 的行数组，或者 ‘F’ 用于 FORTRAN 的列数组</td></tr></tbody></table><p><code>numpy.ones</code> 创建指定形状的数组，数组元素以 1 来填充：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.ones(shape, dtype = <span class="hljs-literal">None</span>, order = <span class="hljs-string">&#x27;C&#x27;</span>)<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">shape</td><td align="left">数组形状</td></tr><tr><td align="left">dtype</td><td align="left">数据类型，可选 默认为浮点数</td></tr><tr><td align="left">order</td><td align="left">‘C’ 用于 C 的行数组，或者 ‘F’ 用于 FORTRAN 的列数组</td></tr></tbody></table><p><code>numpy.zeros_like</code>  <code>numpy.ones_like</code> 创建一个模仿数组，以1或者0进行填充。</p><p>numpy.asarray 类似 numpy.array，但 numpy.asarray 参数只有三个，比 numpy.array 少两个。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">numpy.asarray(a, dtype = None, <span class="hljs-keyword">order</span> <span class="hljs-title">= None</span>)<br></code></pre></td></tr></table></figure><p>参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">a</td><td align="left">任意形式的输入参数，可以是，列表, 列表的元组, 元组, 元组的元组, 元组的列表，多维数组</td></tr><tr><td align="left">dtype</td><td align="left">数据类型，可选</td></tr><tr><td align="left">order</td><td align="left">可选，有”C”和”F”两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。</td></tr></tbody></table><p>例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>a = np.asarray(x)<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure><h6 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]<br><span class="hljs-comment">#由此可以看出list和array的区别</span><br></code></pre></td></tr></table></figure><p><code>numpy.frombuffer</code> 用于实现动态数组。</p><p><code>numpy.frombuffer</code> 接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.frombuffer(buffer, dtype = <span class="hljs-built_in">float</span>, count = -<span class="hljs-number">1</span>, offset = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">buffer</td><td align="left">可以是任意对象，会以流的形式读入。</td></tr><tr><td align="left">dtype</td><td align="left">返回数组的数据类型，可选</td></tr><tr><td align="left">count</td><td align="left">读取的数据数量，默认为-1，读取所有数据。</td></tr><tr><td align="left">offset</td><td align="left">读取的起始位置，默认为0。</td></tr></tbody></table><p><code>numpy.fromiter</code> 方法从可迭代对象中建立 ndarray 对象，返回一维数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.fromiter(iterable, dtype, count=-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">iterable</td><td align="left">可迭代对象</td></tr><tr><td align="left">dtype</td><td align="left">返回数组的数据类型</td></tr><tr><td align="left">count</td><td align="left">读取的数据数量，默认为-1，读取所有数据</td></tr></tbody></table><p>从数值范围创建数组</p><p>numpy 包中的使用 arange 函数创建数值范围并返回 ndarray 对象，函数格式如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">numpy.<span class="hljs-built_in">arange</span>(start, stop, step, dtype)<br></code></pre></td></tr></table></figure><p>根据 start 与 stop 指定的范围以及 step 设定的步长，生成一个 ndarray。</p><p>参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>start</code></td><td align="left">起始值，默认为<code>0</code></td></tr><tr><td align="left"><code>stop</code></td><td align="left">终止值（不包含）</td></tr><tr><td align="left"><code>step</code></td><td align="left">步长，默认为<code>1</code></td></tr><tr><td align="left"><code>dtype</code></td><td align="left">返回<code>ndarray</code>的数据类型，如果没有提供，则会使用输入数据的类型。</td></tr></tbody></table><p><code>numpy.linspace</code> 函数用于创建一个一维数组，数组是一个等<strong>差数列构</strong>成的，格式如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">np.linspace(start, stop, <span class="hljs-attribute">num</span>=50, <span class="hljs-attribute">endpoint</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">retstep</span>=<span class="hljs-literal">False</span>, <span class="hljs-attribute">dtype</span>=None)<br></code></pre></td></tr></table></figure><p>参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>start</code></td><td align="left">序列的起始值</td></tr><tr><td align="left"><code>stop</code></td><td align="left">序列的终止值，如果<code>endpoint</code>为<code>true</code>，该值包含于数列中</td></tr><tr><td align="left"><code>num</code></td><td align="left">要生成的等步长的样本数量，默认为<code>50</code></td></tr><tr><td align="left"><code>endpoint</code></td><td align="left">该值为 <code>true</code> 时，数列中包含<code>stop</code>值，反之不包含，默认是True。</td></tr><tr><td align="left"><code>retstep</code></td><td align="left">如果为 True 时，生成的数组中会显示间距，反之不显示。</td></tr><tr><td align="left"><code>dtype</code></td><td align="left"><code>ndarray</code> 的数据类型</td></tr></tbody></table><p><code>numpy.logspace</code> 函数用于创建一个于<strong>等比数列</strong>。格式如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">np.logspace(start, stop, <span class="hljs-attribute">num</span>=50, <span class="hljs-attribute">endpoint</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">base</span>=10.0, <span class="hljs-attribute">dtype</span>=None)<br></code></pre></td></tr></table></figure><p>base 参数意思是取对数的时候 log 的下标。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>start</code></td><td align="left">序列的起始值为：base ** start</td></tr><tr><td align="left"><code>stop</code></td><td align="left">序列的终止值为：base ** stop。如果<code>endpoint</code>为<code>true</code>，该值包含于数列中</td></tr><tr><td align="left"><code>num</code></td><td align="left">要生成的等步长的样本数量，默认为<code>50</code></td></tr><tr><td align="left"><code>endpoint</code></td><td align="left">该值为 <code>true</code> 时，数列中中包含<code>stop</code>值，反之不包含，默认是True。</td></tr><tr><td align="left"><code>base</code></td><td align="left">对数 log 的底数。</td></tr><tr><td align="left"><code>dtype</code></td><td align="left"><code>ndarray</code> 的数据类型</td></tr></tbody></table><h3 id="切片和索引"><a href="#切片和索引" class="headerlink" title="切片和索引"></a>切片和索引</h3><p>与list的切片相差不大，使用slice方法或者[:::] (start:finish:step)即可，另外对于多维数组的切分，可使用省略号<code>...</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br><span class="hljs-built_in">print</span>(a[..., <span class="hljs-number">1</span>])  <span class="hljs-comment"># 第2列元素</span><br><span class="hljs-built_in">print</span>(a[<span class="hljs-number">1</span>, ...])  <span class="hljs-comment"># 第2行元素</span><br><span class="hljs-built_in">print</span>(a[..., <span class="hljs-number">1</span>:])  <span class="hljs-comment"># 第2列及剩下的所有元素</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">[[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]<br> [<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br> [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]]<br>---------------------<br>[<span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br>---------------------<br>[<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br>---------------------<br>[[<span class="hljs-number">2</span> <span class="hljs-number">3</span>]<br> [<span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br> [<span class="hljs-number">5</span> <span class="hljs-number">6</span>]]<br></code></pre></td></tr></table></figure><p>整数数组索引是指使用一个数组来访问另一个数组的元素。这个数组中的每个元素都是目标数组中某个维度上的索引值。</p><p>以下实例获取了 4X3 数组中的四个角的元素。 行索引是 [0,0] 和 [3,3]，而列索引是 [0,2] 和 [0,2]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <br> <br>x = np.array([[  <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>],[  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>],[  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>],[  <span class="hljs-number">9</span>,  <span class="hljs-number">10</span>,  <span class="hljs-number">11</span>]])  <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;我们的数组是：&#x27;</span> )<br><span class="hljs-built_in">print</span> (x)<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;\n&#x27;</span>)<br>rows = np.array([[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]]) <br>cols = np.array([[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]]) <br><span class="hljs-comment">#这里的索引是0 0,0 2,3 0,3 2</span><br>y = x[rows,cols]  <br><span class="hljs-built_in">print</span>  (<span class="hljs-string">&#x27;这个数组的四个角元素是：&#x27;</span>)<br><span class="hljs-built_in">print</span> (y)<br><br></code></pre></td></tr></table></figure><h6 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">我们的数组是：<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>]<br> [ <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>]<br> [ <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>]<br> [ <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]]<br><br><br>这个数组的四个角元素是：<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">2</span>]<br> [ <span class="hljs-number">9</span> <span class="hljs-number">11</span>]]<br></code></pre></td></tr></table></figure><p>关于 np.ix_ 的具体使用：</p><p><code>x[np.ix_([1,5,7,2],[0,3,1,2])]</code> 这句话会输出一个4*4的矩阵，其中的元素分别是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">x[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>] x[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] x[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] x[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>x[<span class="hljs-number">5</span>,<span class="hljs-number">0</span>] x[<span class="hljs-number">5</span>,<span class="hljs-number">3</span>] x[<span class="hljs-number">5</span>,<span class="hljs-number">1</span>] x[<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]<br>x[<span class="hljs-number">7</span>,<span class="hljs-number">0</span>] x[<span class="hljs-number">7</span>,<span class="hljs-number">3</span>] x[<span class="hljs-number">7</span>,<span class="hljs-number">1</span>] x[<span class="hljs-number">7</span>,<span class="hljs-number">2</span>]<br>x[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>] x[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] x[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] x[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">y=np.array([[x[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>], x[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], x[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]],\<br>            [x[<span class="hljs-number">5</span>,<span class="hljs-number">0</span>], x[<span class="hljs-number">5</span>,<span class="hljs-number">3</span>], x[<span class="hljs-number">5</span>,<span class="hljs-number">1</span>],x[<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]],\<br>            [x[<span class="hljs-number">7</span>,<span class="hljs-number">0</span>] ,x[<span class="hljs-number">7</span>,<span class="hljs-number">3</span>], x[<span class="hljs-number">7</span>,<span class="hljs-number">1</span>], x[<span class="hljs-number">7</span>,<span class="hljs-number">2</span>]],\<br>            [x[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>], x[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], x[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], x[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]]])<br></code></pre></td></tr></table></figure><p>就是说，如果 np.xi_ 中输入两个列表，则第一个列表存的是待提取元素的行标，第二个列表存的是待提取元素的列标，第一个列表中的每个元素都会遍历第二个列表中的每个值，构成新矩阵的一行元素。</p><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。</p><p>如果两个数组 a 和 b 形状相同，即满足 <strong>a.shape &#x3D;&#x3D; b.shape</strong>，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。</p><p>但是两个数组形状不同时，numpy就触发了广播机制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.array([[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>              [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>],<br>              [<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>],<br>              [<span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>]])<br>b = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br><span class="hljs-built_in">print</span>(a + b)<br></code></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2018/10/image0020619.gif" alt="img"></p><h6 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>]<br> [<span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span>]<br> [<span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span>]<br> [<span class="hljs-number">30</span> <span class="hljs-number">31</span> <span class="hljs-number">32</span>]]<br></code></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>NumPy 迭代器对象<code>numpy.nditer</code>提供了一种灵活访问一个或者多个数组元素的方式。</p><p><code>for x in np.nditer(a, order=&#39;F&#39;):</code>Fortran order，即是列序优先；</p><p><code>for x in np.nditer(a.T, order=&#39;C&#39;):</code>C order，即是行序优先；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> np.nditer(a, op_flags=[<span class="hljs-string">&#x27;readwrite&#x27;</span>]): <br>    x[...]=<span class="hljs-number">2</span>*x <br></code></pre></td></tr></table></figure><p><strong>x[…]</strong> 是修改原 numpy 元素，x 只是个拷贝。</p><p>order &#x3D; ‘C’，numpy 实例（也就是一个多维数组）本身的存储顺序不会因为转置或 order &#x3D; ‘C’ 或 ‘F’ 而改变。</p><p>只是 numpy 实例中，存储了一个默认的访问顺序的字段。</p><p>numpy.copy 做了特殊处理，它拷贝的时候不是直接把对方的内存复制，而是按照上面 order 指定的顺序逐一拷贝。</p><p><strong>for x in np.nditer(a, order &#x3D; ‘C’)</strong>: 可以在循环中另外指定顺序，如果未指定，则按照上面数组的order顺序访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> np.nditer(a, flags = [<span class="hljs-string">&#x27;external_loop&#x27;</span>], order = <span class="hljs-string">&#x27;F&#x27;</span>): <br>    <span class="hljs-built_in">print</span> (x, end=<span class="hljs-string">&quot;, &quot;</span> )<br></code></pre></td></tr></table></figure><p>**flags &#x3D; [‘external_loop’]**，当数组的 order 与在循环中指定的 order 顺序不同时，打印为多个一维数组，当相同时，是整个一个一维数组。</p><h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><p>这一部分基本上一些方法，这里只对方法的函数名和描述给出。</p><p><strong>修改数组形状</strong></p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>reshape</code></td><td align="left">不改变数据的条件下修改形状 numpy.reshape(arr, newshape, order&#x3D;’C’)</td></tr><tr><td align="left"><code>flat</code></td><td align="left">数组元素迭代器</td></tr><tr><td align="left"><code>flatten</code></td><td align="left">返回一份数组拷贝，对拷贝所做的修改不会影响原始数组 ndarray.flatten(order&#x3D;’C’)</td></tr><tr><td align="left"><code>ravel</code></td><td align="left">返回展开数组 numpy.ravel(a, order&#x3D;’C’)</td></tr></tbody></table><p><strong>翻转数组</strong></p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>transpose</code></td><td align="left">对换数组的维度 numpy.transpose(arr, axes)</td></tr><tr><td align="left"><code>ndarray.T</code></td><td align="left">和 <code>self.transpose()</code> 相同</td></tr><tr><td align="left"><code>rollaxis</code></td><td align="left">向后滚动指定的轴 numpy.rollaxis(arr, axis, start)</td></tr><tr><td align="left"><code>swapaxes</code></td><td align="left">对换数组的两个轴 numpy.swapaxes(arr, axis1, axis2)</td></tr></tbody></table><p><strong>修改数组维度</strong></p><table><thead><tr><th align="left">维度</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>broadcast</code></td><td align="left">产生模仿广播的对象</td></tr><tr><td align="left"><code>broadcast_to</code></td><td align="left">将数组广播到新形状 numpy.broadcast_to(array, shape, subok)</td></tr><tr><td align="left"><code>expand_dims</code></td><td align="left">扩展数组的形状  numpy.expand_dims(arr, axis)</td></tr><tr><td align="left"><code>squeeze</code></td><td align="left">从数组的形状中删除一维条目 numpy.squeeze(arr, axis)</td></tr></tbody></table><p><strong>连接数组</strong></p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>concatenate</code></td><td align="left">连接沿现有轴的数组序列 numpy.concatenate((a1, a2, …), axis)</td></tr><tr><td align="left"><code>stack</code></td><td align="left">沿着新的轴加入一系列数组。 numpy.stack(arrays, axis)</td></tr><tr><td align="left"><code>hstack</code></td><td align="left">水平堆叠序列中的数组（列方向）</td></tr><tr><td align="left"><code>vstack</code></td><td align="left">竖直堆叠序列中的数组（行方向）</td></tr></tbody></table><p><strong>分割数组</strong></p><table><thead><tr><th align="left">函数</th><th align="left">数组及操作</th></tr></thead><tbody><tr><td align="left"><code>split</code></td><td align="left">将一个数组分割为多个子数组 numpy.split(ary, indices_or_sections, axis)</td></tr><tr><td align="left"><code>hsplit</code></td><td align="left">将一个数组水平分割为多个子数组（按列）</td></tr><tr><td align="left"><code>vsplit</code></td><td align="left">将一个数组垂直分割为多个子数组（按行）</td></tr></tbody></table><p><strong>数组元素的添加与删除</strong></p><table><thead><tr><th align="left">函数</th><th align="left">元素及描述</th></tr></thead><tbody><tr><td align="left"><code>resize</code></td><td align="left">返回指定形状的新数组 numpy.resize(arr, shape)</td></tr><tr><td align="left"><code>append</code></td><td align="left">将值添加到数组末尾 numpy.append(arr, values, axis&#x3D;None)</td></tr><tr><td align="left"><code>insert</code></td><td align="left">沿指定轴将值插入到指定下标之前 numpy.insert(arr, obj, values, axis)</td></tr><tr><td align="left"><code>delete</code></td><td align="left">删掉某个轴的子数组，并返回删除后的新数组 Numpy.delete(arr, obj, axis)</td></tr><tr><td align="left"><code>unique</code></td><td align="left">查找数组内的唯一元素 numpy.unique(arr, return_index, return_inverse, return_counts)</td></tr></tbody></table><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>Numpy也是内置位运算函数的，我认为这部分了解即可</p><p><a href="https://www.runoob.com/numpy/numpy-binary-operators.html">菜鸟教程-NumPy 位运算</a></p><p>NumPy <strong>“bitwise_”</strong> 开头的函数是位运算函数。</p><p>NumPy 位运算包括以下几个函数：</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bitwise_and</code></td><td align="left">对数组元素执行位与操作</td></tr><tr><td align="left"><code>bitwise_or</code></td><td align="left">对数组元素执行位或操作</td></tr><tr><td align="left"><code>invert</code></td><td align="left">按位取反</td></tr><tr><td align="left"><code>left_shift</code></td><td align="left">向左移动二进制表示的位</td></tr><tr><td align="left"><code>right_shift</code></td><td align="left">向右移动二进制表示的位</td></tr></tbody></table><p><strong>注：</strong>也可以使用 “&amp;”、 “~”、 “|” 和 “^” 等操作符进行计算。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Numpy的字符串函数是基于Python内置库中的标准字符串函数。</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>add()</code></td><td align="left">对两个数组的逐个字符串元素进行连接</td></tr><tr><td align="left"><code>multiply()</code></td><td align="left">返回按元素多重连接后的字符串</td></tr><tr><td align="left"><code>center()</code></td><td align="left">居中字符串</td></tr><tr><td align="left"><code>capitalize()</code></td><td align="left">将字符串第一个字母转换为大写</td></tr><tr><td align="left"><code>title()</code></td><td align="left">将字符串的每个单词的第一个字母转换为大写</td></tr><tr><td align="left"><code>lower()</code></td><td align="left">数组元素转换为小写</td></tr><tr><td align="left"><code>upper()</code></td><td align="left">数组元素转换为大写</td></tr><tr><td align="left"><code>split()</code></td><td align="left">指定分隔符对字符串进行分割，并返回数组列表</td></tr><tr><td align="left"><code>splitlines()</code></td><td align="left">返回元素中的行列表，以换行符分割</td></tr><tr><td align="left"><code>strip()</code></td><td align="left">移除元素开头或者结尾处的特定字符</td></tr><tr><td align="left"><code>join()</code></td><td align="left">通过指定分隔符来连接数组中的元素</td></tr><tr><td align="left"><code>replace()</code></td><td align="left">使用新字符串替换字符串中的所有子字符串</td></tr><tr><td align="left"><code>decode()</code></td><td align="left">数组元素依次调用<code>str.decode</code></td></tr><tr><td align="left"><code>encode()</code></td><td align="left">数组元素依次调用<code>str.encode</code></td></tr></tbody></table><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>提供了标准的三角函数：**sin()、cos()、tan()**。</p><p><strong>arcsin，arccos，和 arctan</strong> 函数返回给定角度的 sin，cos 和 tan 的反三角函数。</p><p>这些函数的结果可以通过<code>numpy.degrees()</code>函数将弧度转换为角度。</p><p><code>numpy.around()</code> 函数返回指定数字的四舍五入值。<br><code>numpy.around(a,decimals)</code> decimals: 舍入的小数位数。 默认值为0。 如果为负，整数将四舍五入到小数点左侧的位置</p><p><code>numpy.floor()</code> 返回小于或者等于指定表达式的最大整数，即向下取整。</p><p><code>numpy.ceil()</code> 返回大于或者等于指定表达式的最小整数，即向上取整。</p><p>NumPy 算术函数包含简单的加减乘除: <strong>add()<strong>，</strong>subtract()<strong>，</strong>multiply()</strong> 和 **divide()**。</p><p><code>numpy.reciprocal() </code>函数返回参数逐元素的<strong>倒数</strong>。如 <strong>1&#x2F;4</strong> 倒数为 <strong>4&#x2F;1</strong>。</p><p><code>numpy.power() </code>函数将第一个输入数组中的元素作为底数，计算它与第二个输入数组中相应元素的幂。</p><p><code>numpy.mod() </code>计算输入数组中相应元素的相除后的余数。函数<code>numpy.remainder()</code>也产生相同的结果。</p><h3 id="统计学"><a href="#统计学" class="headerlink" title="统计学"></a>统计学</h3><p>NumPy 提供了很多统计函数，用于从数组中查找最小元素，最大元素，百分位标准差和方差等。</p><p>这些统计学函数通常带有较多的传入参数，详见<a href="https://www.runoob.com/numpy/numpy-statistical-functions.html">统计学函数</a></p><p><code>numpy.amin()</code> 用于计算数组中的元素沿指定轴的最小值。</p><p><code>numpy.amax() </code>用于计算数组中的元素沿指定轴的最大值。</p><p><code>numpy.ptp()</code>函数计算数组中元素最大值与最小值的差（最大值 - 最小值）。</p><p><code>numpy.percentile()</code>百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。 </p><p><code>numpy.median() </code>函数用于计算数组 a 中元素的中位数（中值）</p><p><code>numpy.mean()</code> 函数返回数组中元素的算术平均值，如果提供了轴，则沿其计算。</p><p><code>numpy.average() </code>函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。</p><p>标准差是一组数据平均值分散程度的一种度量。标准差是方差的算术平方根。</p><p>标准差公式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">std = sqrt(mean((x - x.mean())**<span class="hljs-number">2</span>))<br><span class="hljs-comment">#使用例：</span><br><span class="hljs-built_in">print</span> (np.std([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]))<br>&gt;&gt; <span class="hljs-number">1.1180339887498949</span><br></code></pre></td></tr></table></figure><p>统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，</p><p>即 <code>mean((x - x.mean())** 2)</code></p><p>换句话说，标准差是方差的平方根。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用例：</span><br><span class="hljs-built_in">print</span> (np.var([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]))<br>&gt;&gt; <span class="hljs-number">1.25</span><br></code></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><table><thead><tr><th align="left">种类</th><th align="left">速度</th><th align="left">最坏情况</th></tr></thead><tbody><tr><td align="left"><code>quicksort</code>（快速排序）</td><td align="left">1</td><td align="left"><code>O(n^2)</code></td></tr><tr><td align="left"><code>mergesort</code>（归并排序）</td><td align="left">2</td><td align="left"><code>O(n*log(n))</code></td></tr><tr><td align="left"><code>heapsort</code>（堆排序）</td><td align="left">3</td><td align="left"><code>O(n*log(n))</code></td></tr></tbody></table><p><code>numpy.sort() </code>函数返回输入数组的排序副本，numpy中还能以字段关键字排序。</p><p>倒序使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-built_in">abs</span>(np.sort(-x)) <br></code></pre></td></tr></table></figure><p><code>numpy.argsort() </code>函数返回的是数组值从小到大的索引值。</p><p><code>numpy.lexsort() </code>用于对多个序列进行排序。把它想象成对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>msort(a)</code></td><td align="left">数组按第一个轴排序，返回排序后的数组副本。np.msort(a) 相等于 np.sort(a, axis&#x3D;0)。</td></tr><tr><td align="left"><code>sort_complex(a)</code></td><td align="left">对复数按照先实部后虚部的顺序进行排序。</td></tr><tr><td align="left"><code>partition(a, kth[, axis, kind, order])</code></td><td align="left">指定一个数，对数组进行分区</td></tr><tr><td align="left"><code>argpartition(a, kth[, axis, kind, order])</code></td><td align="left">可以通过关键字 kind 指定算法沿着指定轴对数组进行分区</td></tr></tbody></table><p><code>numpy.argmax()</code> 和 <code>numpy.argmin()</code>函数分别沿给定轴返回最大和最小元素的索引。</p><p><code>numpy.nonzero() </code>函数返回输入数组中非零元素的索引。</p><p><code>numpy.where() </code>函数返回输入数组中满足给定条件的元素的索引。</p><p><code>numpy.extract()</code>函数根据某个条件从数组中抽取元素，返回满条件的元素。</p><h3 id="字节交换"><a href="#字节交换" class="headerlink" title="字节交换"></a>字节交换</h3><ul><li><strong>大端模式：</strong>指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。</li><li><strong>小端模式：</strong>指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。</li></ul><p><code>numpy.ndarray.byteswap() </code>函数将 ndarray 中每个元素中的字节进行大小端转换。</p><p>(我并不知道这样做这有什么用)</p><h3 id="副本和视图"><a href="#副本和视图" class="headerlink" title="副本和视图"></a>副本和视图</h3><p>和数据库语言的副本、视图类似。</p><p>视图或浅拷贝：<code>ndarray.view() </code>方会创建一个新的数组对象，该方法创建的新数组的维数变化不会改变原始数据的维数。</p><p>副本或深拷贝：<code>ndarray.copy() </code>函数创建一个副本。 对副本数据进行修改，不会影响到原始数据，它们物理内存不在同一位置。</p><h3 id="矩阵（matrix）与线性代数"><a href="#矩阵（matrix）与线性代数" class="headerlink" title="矩阵（matrix）与线性代数"></a>矩阵（matrix）与线性代数</h3><p>一个 m * n 的矩阵</p><p>转置： numpy.transpose 函数来对换数组的维度，还可以使用 <strong>T</strong> 属性。例如有个 m 行 n 列的矩阵，使用 t() 函数就能转换为 n 行 m 列的矩阵。</p><p><code>matlib.empty() </code>函数返回一个新的矩阵。</p><p><code>numpy.matlib.zeros() </code>函数创建一个以 0 填充的矩阵。</p><p><code>numpy.matlib.ones()</code>函数创建一个以 1 填充的矩阵。</p><p><code>numpy.matlib.eye()</code> 函数返回一个矩阵，对角线元素为 1，其他位置为零。</p><p><code>numpy.matlib.identity() </code>函数返回给定大小的单位矩阵。</p><p><code>numpy.matlib.rand() </code>函数创建一个给定大小的矩阵，数据是随机填充的。</p><p><strong>线性代数</strong>函数库 <strong>linalg</strong>，该库包含了线性代数所需的所有功能</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>dot</code></td><td align="left">两个数组的点积，即元素对应相乘。numpy.dot(a, b, out&#x3D;None)</td></tr><tr><td align="left"><code>vdot</code></td><td align="left">两个向量的点积</td></tr><tr><td align="left"><code>inner</code></td><td align="left">两个数组的内积</td></tr><tr><td align="left"><code>matmul</code></td><td align="left">两个数组的矩阵积</td></tr><tr><td align="left"><code>determinant</code></td><td align="left">数组的行列式</td></tr><tr><td align="left"><code>solve</code></td><td align="left">求解线性矩阵方程</td></tr><tr><td align="left"><code>inv</code></td><td align="left">计算矩阵的乘法逆矩阵</td></tr></tbody></table><p><code>numpy.linalg.det() </code>函数计算输入矩阵的行列式。</p><p><code>numpy.linalg.solve() </code>函数给出了矩阵形式的线性方程的解。</p><p><a href="https://www.runoob.com/numpy/numpy-linear-algebra.html">详见</a></p><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p>NumPy 为 ndarray 对象引入了一个简单的文件格式：<strong>npy</strong>。</p><p>npy 文件用于存储重建 ndarray 所需的数据、图形、dtype 和其他信息。</p><p><code>numpy.save() </code>函数将数组保存到以 .npy 为扩展名的文件中。</p><p><code>numpy.savez() </code>函数将多个数组保存到以 npz 为扩展名的文件中。</p><p><code>savetxt()</code> 函数是以简单的文本文件格式存储数据，对应的使用<code> loadtxt()</code> 函数来获取数据。</p><h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><p>Matplotlib 是 Python 的绘图库。 它可与 NumPy 一起使用，提供了一种有效的 MatLab 开源替代方案。 它也可以和图形工具包一起使用，如 PyQt 和 wxPython。</p><p><a href="https://search.bilibili.com/all?keyword=Matplotlib&from_source=webtop_search&spm_id_from=333.1007&search_source=5">详见</a></p><p>FINISH TIME ： </p><p>10:37:37  2023年9月12日星期二</p>]]></content>
    
    
    
    <tags>
      
      <tag>Numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-基础部分-2-数学基础</title>
    <link href="/2023/09/08/1-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86-2-%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/09/08/1-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86-2-%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1-基础部分-1-Python</title>
    <link href="/2023/09/08/1-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86-1-Python/"/>
    <url>/2023/09/08/1-%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86-1-Python/</url>
    
    <content type="html"><![CDATA[<h1>Chapter 1</h1><h2 id="1-1-分解序列"><a href="#1-1-分解序列" class="headerlink" title="1.1 分解序列"></a>1.1 分解序列</h2><p>需要元素数量匹配，除了元组和列表，其余可迭代也可执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">data = [<span class="hljs-string">&#x27;ACME&#x27;</span>, <span class="hljs-number">50</span>, <span class="hljs-number">91.9</span>, (<span class="hljs-number">2023</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>)]<br>name, shares, price, data = data<br><br><span class="hljs-built_in">print</span>(name, data)<br><br></code></pre></td></tr></table></figure><h6 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">ACME (<span class="hljs-number">2023</span>, <span class="hljs-number">9</span>, <span class="hljs-number">9</span>)<br></code></pre></td></tr></table></figure><h2 id="1-2-从可迭代对象中分解元素"><a href="#1-2-从可迭代对象中分解元素" class="headerlink" title="1.2 从可迭代对象中分解元素"></a>1.2 从可迭代对象中分解元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">avg</span>(<span class="hljs-params">nums</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(nums)/<span class="hljs-built_in">len</span>(nums)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">drop_fst_and_lst</span>(<span class="hljs-params">self</span>):<br>    fst, *mid, lst = self<br>    <span class="hljs-keyword">return</span> avg(mid)<br><br><br>grades = [<span class="hljs-number">100</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(drop_fst_and_lst(grades))<br></code></pre></td></tr></table></figure><h6 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">10.0</span><br></code></pre></td></tr></table></figure><p>Tips:</p><p>将函数传入值改为self可避免暴露函数内的变量名。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">line = <span class="hljs-string">&#x27;gting:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false&#x27;</span><br><br>unmae, *fields, homedir, sh = line<span class="hljs-selector-class">.split</span>(<span class="hljs-string">&#x27;:&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(unmae)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(homedir)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(sh)</span></span><br></code></pre></td></tr></table></figure><h6 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">gting<br>/var/empty<br>/usr/<span class="hljs-built_in">bin</span>/false<br></code></pre></td></tr></table></figure><h2 id="1-3-双向队列"><a href="#1-3-双向队列" class="headerlink" title="1.3 双向队列"></a>1.3 双向队列</h2><p>初始化：<code>q = deque(maxlen=?)</code></p><p><code>q.append(?)</code> 右侧插入元素</p><p><code>q.appendleft(?)</code> 左侧插入元素</p><p><code>q.pop()</code> 弹出右侧元素</p><p><code>q.popleft()</code> 弹出左侧元素</p><p>如果不指定队列的大小就是一个无限的队列，可在两段进行插入和弹出，并且都是O(1)，而列表是O(n)</p><h2 id="1-4-堆heapq"><a href="#1-4-堆heapq" class="headerlink" title="1.4 堆heapq"></a>1.4 堆<code>heapq</code></h2><p>找到最大或者最小的N个元素。</p><p><code>imort heapq</code></p><p><code>heapq</code>中有两个函数 <code>nlargest()</code> 和 <code>nsmallest()</code> </p><p><code>heapq.nlargest(?, ?list, key)</code> 取出最大的前三项，最小同理。</p><p><code>heapq.heapify(?list)</code>将list排序为小顶堆</p><p><code>heapq.heappop()</code> 获取弹出对顶元素，O(logn)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><br>portfolio = [<br>   &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;IBM&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">91.1</span>&#125;,<br>   &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;AAPL&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">543.22</span>&#125;,<br>   &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;FB&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">21.09</span>&#125;,<br>   &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;HPQ&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">35</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">31.75</span>&#125;,<br>   &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;YHOO&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">45</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">16.35</span>&#125;,<br>   &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;ACME&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">75</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">115.65</span>&#125;<br>]<br><br>cheap = heapq.nsmallest(<span class="hljs-number">3</span>, portfolio, key=<span class="hljs-keyword">lambda</span> s: s[<span class="hljs-string">&#x27;price&#x27;</span>])<br>expensive = heapq.nlargest(<span class="hljs-number">3</span>, portfolio, key=<span class="hljs-keyword">lambda</span> s: s[<span class="hljs-string">&#x27;price&#x27;</span>])<br><br><span class="hljs-built_in">print</span>(cheap)<br><span class="hljs-built_in">print</span>(expensive)<br></code></pre></td></tr></table></figure><h6 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">[&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;YHOO&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">45</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">16.35</span>&#125;, &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;FB&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">21.09</span>&#125;, &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;HPQ&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">35</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">31.75</span>&#125;]<br>[&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;AAPL&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">543.22</span>&#125;, &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;ACME&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">75</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">115.65</span>&#125;, &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;IBM&#x27;</span>, <span class="hljs-string">&#x27;shares&#x27;</span>: <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">91.1</span>&#125;]<br></code></pre></td></tr></table></figure><h2 id="1-5-优先队列"><a href="#1-5-优先队列" class="headerlink" title="1.5 优先队列"></a>1.5 优先队列</h2><p>使用 <code>heap</code>实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># example.py</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Example of a priority queue</span><br><br><span class="hljs-keyword">import</span> heapq<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self._queue = []<br>        self._index = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, item, priority</span>):<br>        heapq.heappush(self._queue, (-priority, self._index, item))<br>        self._index += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> heapq.heappop(self._queue)[-<span class="hljs-number">1</span>]<br><br><br><span class="hljs-comment"># Example use</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Item</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Item(&#123;!r&#125;)&#x27;</span>.<span class="hljs-built_in">format</span>(self.name)<br><br><br>q = PriorityQueue()<br>q.push(Item(<span class="hljs-string">&#x27;foo&#x27;</span>), <span class="hljs-number">1</span>)<br>q.push(Item(<span class="hljs-string">&#x27;bar&#x27;</span>), <span class="hljs-number">5</span>)<br>q.push(Item(<span class="hljs-string">&#x27;spam&#x27;</span>), <span class="hljs-number">4</span>)<br>q.push(Item(<span class="hljs-string">&#x27;grok&#x27;</span>), <span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Should be bar:&quot;</span>, q.pop())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Should be spam:&quot;</span>, q.pop())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Should be foo:&quot;</span>, q.pop())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Should be grok:&quot;</span>, q.pop())<br></code></pre></td></tr></table></figure><h6 id="Output-4"><a href="#Output-4" class="headerlink" title="Output"></a>Output</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Should be bar: Item(<span class="hljs-string">&#x27;bar&#x27;</span>)<br>Should be spam: Item(<span class="hljs-string">&#x27;spam&#x27;</span>)<br>Should be foo: Item(<span class="hljs-string">&#x27;foo&#x27;</span>)<br>Should be grok: Item(<span class="hljs-string">&#x27;grok&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="1-6-一键多值字典multdct"><a href="#1-6-一键多值字典multdct" class="headerlink" title="1.6 一键多值字典multdct"></a>1.6 一键多值字典<code>multdct</code></h2><p>使用<code>from collections import defaultdict</code></p><p>使用例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">d = defaultdict(<span class="hljs-built_in">list</span>)<br>d[<span class="hljs-string">&#x27;a&#x27;</span>].append(<span class="hljs-number">1</span>)<br>d[<span class="hljs-string">&#x27;a&#x27;</span>].append(<span class="hljs-number">2</span>)<br><br>d2 = defaultdict(<span class="hljs-built_in">set</span>)<br>d2[<span class="hljs-string">&#x27;a&#x27;</span>].add(<span class="hljs-number">1</span>)<br>d2[<span class="hljs-string">&#x27;a&#x27;</span>].add(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h2 id="1-7-有序字典"><a href="#1-7-有序字典" class="headerlink" title="1.7 有序字典"></a>1.7 有序字典</h2><p>使用<code>from collections import OrderedDict</code> 会严格按照字典添加的顺序进行。</p><p>可在JSON编码中控制各字段的顺序。</p><p>1.8 字典中的计算</p>]]></content>
    
    
    
    <tags>
      
      <tag>深度学习入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-机器学习-1-理论</title>
    <link href="/2023/09/08/3-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-1-%E7%90%86%E8%AE%BA/"/>
    <url>/2023/09/08/3-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-1-%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>test1</title>
    <link href="/2023/09/08/test1/"/>
    <url>/2023/09/08/test1/</url>
    
    <content type="html"><![CDATA[<p>Hello World</p><p>Hello Everyone</p><p><code>print(&#39;hello world!&#39;)</code></p><p>你好！</p><p>Test image</p><p><img src="/../images/Irena.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/09/05/hello-world/"/>
    <url>/2023/09/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
